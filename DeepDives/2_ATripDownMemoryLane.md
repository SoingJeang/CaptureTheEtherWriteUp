<!--
 * @Author: Soingjeang
 * @Date: 2022-08-05 15:20:00
 * @LastEditors: SoingJeang
 * @LastEditTime: 2022-08-08 19:26:52
 * @FilePath: \CapTheEther\DeepDives\2_ATripDownMemoryLane.md
-->
# 以太坊虚拟机内存之旅
#### 在第一章部分我们介绍了以太坊虚拟机EVM如何寻找到对应函数所在的字节码的位置，同时我们也大致了解以太坊虚拟机EVM的堆栈，输入参数信息，函数签名以及以太坊虚拟机EVM操作码的指令。
#### 本章我们将深入到“内存”中，我们将对内存有个全面的了解，以及内存如何在EVM下工作的。

#### 我们继续以第一章的合约来分析
#  Storages.sol Breakdown
```Solidity
    pragma solidity ^0.4.21;

    /// @title Storages
    /// @dev store & retrieve value in a variable
    contract Storages {
        uint256 number;

        /// @dev Store value in variable
        /// @param num value to store
        function store(uint256 num) public {
            number = num;
        }

        /// @dev  Return value
        /// @return value of number
        function retrieve() public view returns(uint256) {
            return number;
        }
    }
```
#### 我们过去编译生成了全部字节码，并完成选择函数部分的分析。本文中，我们聚焦于一下字符串
```
6060604052
6060                =   PUSH1 0x60
6040                =   PSUH1 0x40
52                  =   MSTORE
```
#### 这5个字节代表初始化内存指针为空。为了理解它的目的，我们必须对合约内存管理的数据结构有一定的了解。
<br>

# 内存数据结构
#### 合约的内存是一个简单的字节数组。其中数据可以以32字节（256位）或者1字节（8位）存储在内存块中，同时可以以32字节（256位）的块大小去读取其中数据。
#### 以下三个指令用于内存的操作
- MSTORE(x, y)  - 存储一个32字节（256位）大小的数据"y",存放在内存中"x"的位置上
- MLOAD(x)      - 读取内存中"x"的位置上的一个32字节（256位）大小的数据并压入栈中
- MSTORE8(x, y) - 存储一个1字节（8位）大小的数据"y",存放在内存中"x"的位置上(放在最低有效字节上)

#### 以太坊虚拟机内存每个插槽大小为1字节（8位）。上面数据结构提到的位置，即为从哪个插槽开始读取或写入。当然，如果想要读取或写入大于1字节的数据，此时需要用到下个插槽。

# 以太坊虚拟机EVM 实验

#### 跟上一章一样，我们继续商用https://www.evm.codes/playground 来理解这3中操作码和内存位置的工作方式。单击run按钮。接着使用右上角的step into 单步调试功能，单步运行命令并观察堆栈和内存是如何变化的。我们将一下代码以mon方式输入实验
```
// 存储 32 字节 0x11...1 在 0 位置上
PUSH32 0x1111111111111111111111111111111111111111111111111111111111111111
PUSH1 0x00
MSTORE

// 存储 1 byte 0x22 在位置 32 上(0x20)
PUSH1 0x22
PUSH1 0x20
MSTORE8

// 存储 1 byte 0x33 在位置 33 (0x21)
PUSH1 0x33
PUSH1 0x21
MSTORE8

// 在位置 0 读取 32 字节并压入堆栈
PUSH1 0x00
MLOAD

// 在位置 0x20 读取 32 字节并压入堆栈
PUSH1 0x20
MLOAD

// 在位置 0x21 读取 32 字节并压入堆栈
PUSH1 0x21
MLOAD
```
#### 如果读者正在做实验，可能会发现一些奇怪的变化，一开始，我们使用MSTORE8存储一个字节数据(0x22)到内存中的(0x20)0x1111111111111111111111111111111111111111111111111111111111111111
变化为:
0x11111111111111111111111111111111111111111111111111111111111111112200000000000000000000000000000000000000000000000000000000000000
这我们只增加1字节数据，怎么多出来那么多0呢。
<br>

# 内存拓展

#### 当我们的合约部署到链上后，以太坊合约内存的写入需要按字节大小花费gas。如果你写入的内存区域之前没有被写过的话，这就需要在使用前拓展内存并为它提供额外的花费。内存拓展的花费在前724字节是按先行增长的，但是往后的增长将会按二次幂方增长。
#### 一开始我们内存中存在一个32字节大小的数据。当我们在内存位置32的地方写入1字节大小信息。这时我们将要写入的内存区域未创建，此时我们就要进行内存拓展，意味着需要增加32字节大小的新内存。当前我们内存使用增加到64字节。内存初始化时将会把所有位置为0。所以我们看到新加的内存信息为0x2200000000000000000000000000000000000000000000000000000000000000

# 内存是一个字节数组
#### 当我们执行MLOAD命令，从内存位置33(0x21)读取32字节大小数据，查看堆栈，发现栈顶为: 0x3300000000000000000000000000000000000000000000000000000000000000。表明我们可以从非32字节位置开始读取。因为内存是一个字节数组，所以我们可以在任意位置读写而不必被32所限制。并且内存是线性的，可以按字节定位。
### 内存只可以在函数内部创建。它既可以被复杂类型如：array、struct初始化(如new int[...])也可以拷贝自存储去的引用变量。
#### 现在我们大致了解了内存数据结构，让我们回到初始化空闲内存指针位置。
<br>

# 空闲内存指针
#### 空闲内存指针是一个指向空闲内存位置的指针。它使得智能合约能够明确哪块内存是已写的，哪块是空闲的。这可以防止合约覆盖已经分配给其他变量的内存。当一个变量正在写入内存时，智能合约会先参考空闲内存指针确定数据应该存储在什么位置。写入后，它通过计算当前写入的数据量来更新空闲内存指针的值，原空闲内存指针与数据量大小相加即产生新的空闲内存指针位置。

# 字节码
 ```
6060604052
6060                =   PUSH1 0x60
6040                =   PSUH1 0x40
52                  =   MSTORE
```
#### 我们还是回到一开始提到的初始字节码，其中有5个字节大小形成3个命令。PUSH1 0x60是第二个参数值0x60, PSUH1 0x40是第一个参数位置:0x40也就是（64字节）位置放入值（128）。那么问题来了，为什么要在0x40的位置放入初始值0x80呢？请读者在本文中寻找答案。
#### Solidity中有自己的保留分区，分别为暂存空间、空闲内存指针，共3个插槽（一个插槽1字节）。
```
0x00 - 0x3f (64 bytes): 暂存空间

0x40 - 0x5f (32 bytes): 空闲内存指针

```
#### 我们可以看到在前面3个命令中设置了0x40也就是空闲内存指针，将值设置成0x60也就是在第三个插槽后，第一个空闲内存的位置。我们看看这些保留分区用处：
```
暂存空间: 汇编语言中内部使用，如内联汇编和散列方法.
空闲内存指针： 空闲内存的起始位置，初始值是0x60
```

# 上线智能合约中的内存
```
pragma solidity ^0.4.21;

/// @title MemoryLane
/// @dev explain someMemory
contract MemoryLane {
    uint256 number;

    /// @dev Alloc value
    function memoryLane() public pure {
        bytes32[5] memory a;
        bytes32[2] memory b;
        b[0] = bytes32(uint256(1));
    }
}
```
#### 现在，我们来看看上线智能合约中的内存以验证我们刚刚认识到的区块链合约内存。MemoryLane合约是一个简单的合约，它只有一个函数memorylane。函数的功能是定义两个数组变量，分别是长度为5的数组a和长度为2的数组b，并且给b[0]赋值为1。尽管合约很简单，但是执行这3行代码会发生很多事情。
#### 如果读者使用Remix等在线编译的IDE，可以敲入，尝试编译代码，部署代码，并运行memoryLane()函数，可以进入调试模式单步执行每个操作命令。也可以将编译完后的字节码放入我们之前提到的以太坊虚拟机EVM 实验单步运行。
```

```
#### 