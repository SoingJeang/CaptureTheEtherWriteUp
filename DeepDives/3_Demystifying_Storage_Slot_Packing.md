<!--
 * @Author: Soingjeang
 * @Date: 2022-08-09 15:40:02
 * @LastEditors: SoingJeang
 * @LastEditTime: 2022-08-10 16:07:18
 * @FilePath: \CapTheEther\DeepDives\3_Demystifying_Storage_Slot_Packing.md
-->
#  解密存储区

#### 本章将深入了解合约存储器的工作原理，将会提供一些模型帮助深入了解存储器插槽的包装。存储器插槽对研究EVM底层非常重要。如果读者尝试过Caoture The Ether等攻防，应该能了解到它往往是解题的关键。

# 存储区基础
## 数据结构
#### 上一章介绍内存也是从数据结构开始，本章也是从存储区的数据结构开始，将会为其余知识奠定好坚实的基础。存储去基础信息我觉得这个文章很好，读者可以参考这篇文章https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/。本文是更深入扩展。
#### 智能合约的存储区是将一个32字节大小映射到另一个32字节的值。32字节共有256位，所以能映射到2^256-1个值，也就是2^256-1个插槽，以太坊空间用插槽来表示一个32字节的位置。初始化时全部的插槽都是0，并且0是没有必要被占用空间的。2^256-1是一个天文数字，它好比全世界的原子数量，任何计算机都没这么大的控件。这也就是为什么要设置初始值为0的原因。因为0不需要网络的节点来存储。
#### 以太坊存储区的变量可分为固定大小存储、动态数组存储、映射存储

## 固定大小存储
#### 存储区一个插槽是32字节，顾名思义，固定存储就是在固定的插槽存储相应的值。我们聚焦于EVM如何将多个值合并到一个插槽中。我们例子合约：
```
pragma solidity ^0.4.21;

contract StotageTest {
    uint256     value1;
    uint256[2]  value2;
    uint256     value3;
    uint32      value4;
    uint32      value5;
    uint64      value6;
    uint128     value7;
    
}
```
#### 此合约中，变量value1，value2，value3都是固定大小的变量，EVM会根据Solidity中代码的声明顺序保留固定的插槽并把它们放入其中。从插槽0开始线性递增。例子中，value1存放在插槽0；value2占据2个插槽分别为1、2；value3占据插槽3。
#### 现在我们看看变量value4，value5，value6，value7。读者可能因为前一个例子而判断这4个值占据了插槽4、5、6、7。但是恰恰是错的，这4个变量只占据一个插槽4，因为它们声明的变量类型是不同的。1个插槽共32字节，uint32为4字节，uint64位8字节，uint128位16字节，所以4个变量合起来大小为32字节，所以这就是我们要的插槽组装

## 插槽组装
#### solidity编译器决定了固定大小存储插槽的分配。编译器知道一个插槽可以存32字节大小数据，而uint32 value4在插槽4中只占用4字节，还剩28字节空闲；紧接着编译器检查下一个变量uint32 value5;看看它是否可以打包进这个插槽。发现下个变量只有4字节，所以一起打包进去。以此类推，顺序检查后面的变量。我们看看插槽4的变量。
- value4 位于1-4字节
- value5 位于5-8字节
- value6 位于9-16字节
- value7 位于17-32字节
## EVM存储操作码
#### 现在我们了解了存储区的数据结构和插槽组装方式后，让我们看看存储去的2个操作码：SSTORE、SLOAD
### SSTORE
#### SSTORE弹出2个堆栈的32字节参数，一个键、另一个值。此操作是将32字节的值存于32字节的插槽位置。
### SLOAD
#### SLOAD命令弹出1个堆栈的32字节参数为键，读取该键指向的插槽的值，并把值压入堆栈中。
#### 那么问题来了，我们了解到SSTORE和SLOAD都是对32字节的键也就是插槽进行操作，那么对于被组装插槽其中的变量（小于32字节）是如何起作用呢？当我们对插槽4进行SLOAD时，我们将得到插槽4中整个32字节的值。这个值包括value4、value5、value6、value7，EVM如何区分这四个值并返回我们想要的值呢？对于SSTORE也一样，当我们存储插槽4时，同样工作与32字节，EVM怎么确保我们写入value5时不会覆盖value4的值呢，写入value6时不会覆盖value5的值呢？这几个问题我们将在下面慢慢解开。
<br>

# 存储和检索组装变量
#### 我们还是以上面简单合约为例子，这边只有的一个store函数用来设置这些变量。并且读取一个变量来进行算术运算并赋值给了value8。store函数将会回答我们上面提到的所有问题。
#### 这个函数中将多个变量存储在一个存储插槽中并且不会覆盖已有的其他数据，而且需要从一个插槽中读取特定的变量。我们先看看结束时插槽4的信息是什么，然后从后往前推。
```
// 存储插槽4
// 十六进制
0000000000000000000000000000115c000000000000014d0000001600000001
// 二进制
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100010101110000000000000000000000000000000000000000000000000000000001010011010000000000000000000000000001011000000000000000000000000000000001
```
#### 上面就是插槽4中的内存，请记住十六进制只是便于我们查看，对于机器，它都会最终视为2进制计算。这很重要，因为在插槽组装中是按位运算的。这边十六进制的值翻译为10进制为：0x115c=4444，0x14d=333，0x16=22，0x01=1。这些值对应于我们再Solidity代码汇总写入的值。一个32字节大小的插槽共有64个16进制字符或者256个二进制字符。
<br>

## 位运算
#### 插槽组装使用3个位运算操作：AND、OR、NOT。这些与EVM操作码是相同的。让我们继续深入。
## AND
#### AND用于2个数按位相与，两个位都必须是1结果才为1。第一个数的第一位与第二个数的第一个位如果都是1，则结果的第一位为1，往后推，对第二位也是相同的计算方式。如 01100010 AND 10101010 = 00100010。
## OR
#### OR也是用于2个数按位相或，但只要一位是1即结果为1。第一个数的第一位与第二个数的第一个位如果有1个是1，则结果的第一位为1，往后推，对第二位也是相同的计算方式。如 01100010 OR 10101010 = 11101010
## NOT
#### NOT不同于前2个，它只对一个数按位取反。从1位开始，如果是1则结果是0；如果是0则结果为1。如 NOT 01100010 = 10011101。
#### 了解了这些，让我们看看Solidity是如何使用它们的。
<br>

## 插槽操作之SSTORE存储
#### 我们注意到Solidity代码中的 value5 = 22，运行到此时，value4已经被存入插槽4了。我们现在还需要在这个插槽存入额外的数据。对于 value6 = 333，value7 = 4444也会发生同样插槽已有数据并插入新数据的情况，读者也可以通过我们提供的实验进一步探索。让我我们看看初始字节码
```
0x00000016  =   22（value5）
0x00000004  =   4（插槽4）
0x04        =   4（4字节，value5的起始位置）
0x0100      =   256（1字节最大数据） -- 进行指数运算
0xffffffff  =   4字节最大表示大小也就是value5所在位置最大值
// 指数运算结果
0x0000000000000000000000000000000000000000000000000000000100000000
// 指数结果与 value5的值相乘，得到value5要写入的位置以及值也就是value5初始值
0x0000000000000000000000000000000000000000000000000000001600000000
```
#### EVM虚拟机一开始使用指数函数计算，指数函数命令需要两个参数，一个底数以及一个指数。字节码中使用了0x0100作为底数代表1字节大小的偏移，使用了0x04作为指数代表共有4字节，也就是指数运算后我们得到4总字节大小的偏移来到了value5的位置了。
#### 所以当运行完指数运算后我们就可以找到合适的位置插入value5=0x16了。但是我们还不能直接插入值，因为这会覆盖已经存储的value4的值，这时候位运算就要起到作用啦。
```
// 指数运算结果，也就是value5起始位置。
0x0000000000000000000000000000000000000000000000000000000100000000
// 指数结果 乘以 4字节最大值也就是value5的最大值
0x000000000000000000000000000000000000000000000000ffffffff00000000
// 我们对最大值取反 NOT 得到除了value5位置外其他位置都是1，也就是value5位置的比特掩码
0xffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffffff
// 这时我们把插槽4中的值读取进来 SSLOAD,看到值存储了value4的值1
0x0000000000000000000000000000000000000000000000000000000000000001
// 我们将那个值进行与 AND 运算，我们将得到除了value5的其他数据value4、value4=5、value6，并清空value5的值，也就是value5其他值
0x0000000000000000000000000000000000000000000000000000000000000001
```
#### 上面的运算将能获得我们要写入value5时除了value5以外的其他位置的值，并且value5的值已经被设置为0。这时候读者应该也想到了如何写入value5的值了吧，没错，就是将清空value5的值与value5位置的值做或 OR 预算。我们看看如何计算的
```
// Value5值
0x00000016
// 4字节最大值
0xffffffff
// AND 与运算确保value5大小在4字节内而不造成溢出。
0x00000016
// value5位置开始
0x0000000000000000000000000000000000000000000000000000000100000000
// value5位置要设置的值，我们将之称为value5的向量（位置和值）
0x0000000000000000000000000000000000000000000000000000001600000000
// 载入插槽清空value5后的值
0x0000000000000000000000000000000000000000000000000000000000000001
// OR 做或运算
0x0000000000000000000000000000000000000000000000000000001600000001
```
#### 这时我们已经计算出插槽4将要存储的32字节值了，我们可以使用SSTORE命令将这个含有value4和value5的值存入插槽4中了。

## 插槽操作之SLOAD检索
#### 我们注意到Solidity代码函数store的最后一句 uint96 value8 = value3 + uint32(666); 我们不关心其中的算术运算，而是重点关注怎么检索 value6。我们还是从字节码开始。
```
0x04                =   4（插槽4）
0x08                =   8（第8字节）
0x0100              =   256（1字节最大数据） -- 进行指数运算
0xffffffffffffffff  =   8字节最大表示大小也就是value6所在位置最大值
0x0000000000000000000000000000115c000000000000014d0000001600000001 = 插槽4当前的值
```
#### 接下去我们要获得value6位置的值，其实原理和写入值很像。
```
// 指数运算结果，value6起始位置
0x0000000000000000000000000000000000000000000000010000000000000000
// 插槽4当前的值
0x0000000000000000000000000000115c000000000000014d0000001600000001
// DIV 使用除法除以指数value6位置得到
0x00000000000000000000000000000000000000000000115c000000000000014d
// 8字节大小掩码
0x000000000000000000000000000000000000000000000000ffffffffffffffff
// AND 使用与预算，计算插槽除法后的值按位与掩码
0x000000000000000000000000000000000000000000000000000000000000014d
```
#### 这样我们就能从插槽4中得到正确的value6的值了，十六进制的0x14d=333。再一次强调插槽组装中是按位运算的，位掩码和按位计算对于从32字节插槽中提取和存储特定字节很有帮助。我们拥有了value6的值就可以接下去计算 value6 + uint32(666) 的大小了。

# 以太坊虚拟机EVM 实验
#### &emsp现在我们来练习这部分操作命令。您还是需要单步调试以帮助理解得更透彻。
```
PUSH1 0x01              =   放置value4 = 1
PUSH1 0x04              =   插槽4
PUSH1 0x00              =   0字节
PUSH2 0x0100            =   4字节大小
EXP                     =   指数
DUP2
SLOAD                   =   加载插槽4内容
DUP2
PUSH4 0xffffffff        =   value5位置 全1
MUL
NOT                     =   其他位置置1
AND                     =   清空value1位置
SWAP1                   
DUP4
PUSH4 0xffffffff        =   AND 防止value5超过4字节
AND                     
MUL
OR                      =   设置正确的值
SWAP1
SSTORE                  =   存入插槽4
POP
```
#### 这部分汇编代码实现了 Value4 = 1

```
PUSH1 0x16              =   value2 = 0x16
PUSH1 0x04              =   插槽4
PUSH1 0x04              =   4字节，value5的起始位置
PUSH2 0x0100            =   1字节大小
EXP                     =   指数运算 0x0100 ^ 0x04
DUP2                    =   复制插槽4
SLOAD                   =   载入插槽4的内容
DUP2 
PUSH4 0xffffffff              
MUL                     =   获得value5位置全置1
NOT                     =   取反，获得value5的掩码
AND                     =   清空value5的值并保留其他位置的值
SWAP1 
DUP4 
PUSH4 0xffffffff // bitmask 4 bytes length 
AND                     =   确保value5小于4字节
MUL                     =   获得value5的向量
OR                      =   或运算组装value4和value5
SWAP1   
SSTORE                  =   存储到插槽4中
POP 
```
#### 这部分汇编代码实现了 Value5 = 22，它帮助我们回顾刚刚讲授保留value4的值并设置value5的值到插槽中的知识点。

```
PUSH1 0x00
PUSH2 0x029a            =   uint32(666)
PUSH4 0xffffffff 
AND                     =   确保666小于4字节
PUSH1 0x04              =   插槽4
PUSH1 0x08              =   8字节，value6的起始位置
SWAP1                   =
SLOAD                   =   载入插槽4的内容
SWAP1 
PUSH2 0x0100 
EXP                     =   指数运算 x0100 ^ 0x08 = 0x10000000000000000
SWAP1 
DIV                     =   除法运算 移除后面8字节
PUSH8 0xffffffffffffffff 
AND                     =   检索的value6的值
```
#### 这部分汇编代码实现了 uint96 value8 = value6 + uint32(666) 的检索部分，它同样帮我回顾检索value6的知识点。
#### 尽管EVM操作码SSTORE和SLOAD仅仅处理32字节的数据，但是我们可以使用按位计算和位掩码来存储和检索我们想要的具体位置多大的信息而得到我们想要的数据。相信读者此时也解开了本章开始的问题吧，如果不清楚的话请在回顾本章内容！