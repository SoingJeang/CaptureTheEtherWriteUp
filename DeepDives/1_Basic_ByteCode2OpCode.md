<!--
 * @Author: Soingjeang
 * @Date: 2022-07-27 12:01:32
 * @LastEditors: SoingJeang
 * @LastEditTime: 2022-08-05 15:20:20
 * @FilePath: \CapTheEther\DeepDives\1_Basic_ByteCode2OpCode.md
-->
#  前言
#### &emsp;第一原则，要聚集思维思考基础概念。这样我们能更好的理解顶层设计。   

#### &emsp;在只能合约的世界中。围绕“以太坊虚拟机EVM”算法和数据结构是主要的基础概念。然后才是Solidity语言和智能合约这样的顶层设计。为了成了solidity开发工程师必须深入理解以太坊虚拟机EVM。  
#### &emsp;这是本书“深入挖掘EVM”的第一章，深入以太坊是理解基础知识必备的素质。
&nbsp;

#  基础：Solidity->ByteCode(字节码)->OpCode（操作码）
#### &emsp;在本文开始时，读者必须已经掌握基础的Solidity基础知识和如何部署到以太坊链的方法。同时我也会简要概过这部分主题，如果想摄入挖掘，请学习相关内容。
#### &emsp;Solidity需要先编译为字节码才能部署进入以太坊中。这些字节码有对应于一些可以被以太坊虚拟机EVM执行的操作码指令。
#### &emsp;本此列文章聚焦于部分特别字节码，阐明它们的工作方法。你需要在每个章节结束前回调提出的问题。按此方式，你将会掌握大部分以太坊虚拟机EVM的基础知识。
#### &emsp;现在我们开始一个基础的solidity合约和它编译后的字节码ByteCode/操作码OpCode。我们来演示EVM如何选择函数。
#### &emsp;运行时的字节码是整个Solidity合约编译后的信息，代表整个合约。一旦合约部署完成。你可以运行call合约内部的一个函数或者多个函数。
#### &emsp;问题来了：我们执行哪个函数时以太坊虚拟机EVM如何知道所对应的字节码呢？这是我们理解以太坊虚拟接工作的第一个问题。以太坊虚拟机是如何去处理这种情况呢，请看此例子
<br>

#  Storages.sol Breakdown
```Solidity
    pragma solidity ^0.4.21;

    /// @title Storages
    /// @dev store & retrieve value in a variable
    contract Storages {
        uint256 number;

        /// @dev Store value in variable
        /// @param num value to store
        function store(uint256 num) public {
            number = num;
        }

        /// @dev  Return value
        /// @return value of number
        function retrieve() public view returns(uint256) {
            return number;
        }
    }
```

#### &emsp;在此例子中，我们使用 Storages.sol 合约。这个合约拥有2个函数：store() 和 retrieve()。因此以太坊虚拟机需要分清需要执行哪个函数。下面是此合约的字节码。

```
    0x6060604052341561000f57600080fd5b60d38061001d6000396000f300
    6060604052600436106049576000357c0100000000000000000000000000
    000000000000000000000000000000900463ffffffff1680632e64cec114
    604e5780636057361d146074575b600080fd5b3415605857600080fd5b60
    5e6094565b6040518082815260200191505060405180910390f35b341560
    7e57600080fd5b60926004808035906020019091905050609d565b005b60
    008054905090565b80600081905550505600a165627a7a72305820e617e7
    f4250b8b23fd5444b810722168c25afffc26da3945d09cb23eafa8a04e0029
```
#### 让我们关注这些字节码： 
```
6000357c0100000000000000000000000000000000000000000000000000000000
900463ffffffff1680632e64cec114604e5780636057361d14607457
```
<br>

#### &emsp;这部分代码是以太坊虚拟机EVM如何选择函数的逻辑。读者可以使用ctrl + f 查询字节码位置。同时这行字节码也对应一些列顺序执行的执行指令以及输入参数。
#### &emsp;执行指令的操作码长度有 1byte 到 256byte 不同的长度，同时也代表不同的执行指令。以太坊虚拟机只是用140操作码（指令）。
#### &emsp;我们将这片段字节码翻译成它对应的一列写执行指令。这些指令由EVM按调用栈顺序执行。你可以到[OPCODE](https://www.ethervm.io/)去验证操作信息。如60 = PUSH 等等。文字末尾，你将要理解这么做的意义是如何。
```
    60 00                               =   PUSH1 00
    35                                  =   CALLDATALOAD
    7c 01000000000000000000000000000
       00000000000000000000000000000    =   PUSH29 0100000000000000000000000000000000000000000000000000000000
    90                                  =   SWAP
    04                                  =   DIV
    63 ffffffff                         =   PUSH4 0xffffffff
    16                                  =   AND
    80                                  =   DUP1  
    63 2e64cec1                         =   PUSH4 0x2e64cec1
    14                                  =   EQ
    61 003b                             =   PUSH2 0x003b
    57                                  =   JUMPI
    80                                  =   DUP1 
    63 6057361d                         =   PUSH4 0x6057361d     
    14                                  =   EQ
    61 0059                             =   PUSH2 0x0059
    57                                  =   JUMPI  
```

# 执行智能合约函数 和 传递参数
#### &emsp;让我们回顾一下我们如何执行一个只能合约函数。
#### &emsp;我们执行一个智能合约函数时。我们需要将函数签名、函数参数转换为一个16进制字符串传给以太坊虚拟机。如我们执行store(10)时。solidity会这样合并我们的信息：
```
    event FunctionCalldata(bytes);
    bytes memory functionCalldata = abi.encodeWithSignature("store(uint256)", 10)
    emit FunctionCalldata(functionCalldata)
    address(storageContract).call(functionCalldata);
```
#### &emsp;此例子使我们了解到执行一个智能合约函数store，并传入参数10.我们使用abi.encodeWithSignature来合并所需信息得到需要的格式。而emit命令用于输入日志记录得到的信息

```
0x6057361d000000000000000000000000000000000000000000000000000000000000000a
```
#### &emsp;上面的字符串代表了abi.encodeWithSignature("store(uint256)", 10)返回的信息。刚刚我们提到了函数签名，让我们深入看看是什么。“函数签名”定义为：对函数规范表示进行散列函数keccak()运算后的前4字节信息。 在我们的例子中。2个函数的规范表示即为："store(10)"和"retrieve()"。现在我们来计算他们的散列值的前4字节，同时读者也可以自己做运算验证：
```
keccak256("store(10)")      ->      前4字节: 0x6057361d
keccak256("retrieve()")     ->      前4字节: 0x2e64cec1
```
#### &emsp;以上我们生成了36字节的字符串。前四个字节对应于上面使用store(uint256)函数计算的签名值，也是我们选择器的结果。接下来的32字节的字符串是我们的输入参数的十六进制形式。“a”对应于十进制的“10”。
```
0x6057361d => 函数签名 （4字节）
0x000000000000000000000000000000000000000000000000000000000000000a => 
参数 uint256 （32字节）
```

# 操作码和堆栈
#### &emsp;现在，让我们开始深入看看 以太坊虚拟机EVM 在我们函数选择期间做了什么。
#### &emsp;让我们遍历每个操作命令，看看他们做了什么，以及对咱们的堆栈有什么影响
```
PUSH1 0x00
```
#### &emsp;首先，第一个操作码是PUSH1。它搞死以太坊虚拟机EVM向堆栈中压入1字节大小的数据。0x00指的是十进制的“0”。为什么我们需要压入堆栈1个字节的0了，让我们继续往下看
```
CALLDATALOAD
```
#### &emsp;CALLDATALOAD命令是刚刚压入堆栈的1字节大小数据出栈(stack(0))。它使用堆栈这1字节大小信息作为它指向堆栈的位置，堆栈的长度是32字节，但是我们的指令列表字符串长度为36字节。这时候输入的信息为i，堆栈信息为msg.datap[i:i+32]。这就允许堆栈永远只有32字节大小的数据，而指令集列表长度可以任意长。
#### &emsp;这时候我们的偏移就是0了。因为上一个push1压入的是0。所以我们把前32字节大小压入堆栈中，目前堆栈压入的值是：0x6057361d00000000000000000000000000000000000000000000000000000000。但是这最后的“0x0000000a”丢失了。如果我们想补全这个参数uint256的32字节信息，我们将要把偏移改为4。
```
PUSH29 0100000000000000000000000000000000000000000000000000000000
```
#### &emsp;PUSH29 是向堆栈压入29字节大小的数据。此处压入(0x0100000000000000000000000000000000000000000000000000000000)进入堆栈中。这个值后面将用于除法中用到。
```
SWAP
```
#### &emsp;顾名思义，这个命令是交换两个元素的值。它是用来交换栈顶和栈第二个元素的值，此处将0x6057361d00000000000000000000000000000000000000000000000000000000和0x0100000000000000000000000000000000000000000000000000000000进行交换位置。
```
DIV
```
#### &emsp;DIV是一个除法命令它将栈顶元素取出作为被除数，栈第二个元素取出作为除数，相除，得到一个uint256的整数值作为商。并将商压入堆栈中。当前我们的0x6057361d00000000000000000000000000000000000000000000000000000000除以0x100000000000000000000000000000000000000000000000000000000得到0x6057361d并压入栈中。



```
PUSH4 0xffffffff
```
#### &emsp;PUSH4是向堆栈压入4字节大小的数据.此处压入0xffffffff。
```
AND
```
#### &emsp;AND这是一个简单的命令，意思为将栈顶与栈第二个元素都出栈，并将两者按位相与，最后将得到的值压入堆栈中。
```
PUSH4 0x2e64ce1c
```
#### &emsp;PUSH4是向堆栈压入4字节大小的数据。此处压入（0x2e64ce1c）进入堆栈中。这个值是一个函数签名,为retrieve()函数的函数签名，是来自solidity编译器编译后的字节码。编译器掌握所有函数签名和参数信息。
```
EQ
```
#### &emsp;EQ命令弹出2个栈顶数据，并校验两个数据是否相同，如果相同，压入1，否则压入0。此时堆栈弹出0x2e64ce1c和0x6057361d，两者不同，所以压入0。
```
PUSH2 0x003b
```
#### &emsp;PUSH2操作码是是压入2字节大小的数据到堆栈中。此时处我们压入0x003b，它的十进制是59。这是为下一个命令准备的。
#### &emsp;堆栈有个指令可以只想指向字节码指令列表的位置，表示下一个命令会跳过去执行。这里设置的59是我们的函数retrieve()所在字节码中的位置。
```
JUMPI
```
#### &emsp;JUMPI命令意为 jump if. 它弹出2个栈顶元素作为它的输入。第一个元素是等等跳过去执行第几条指令的位置；第二个元素是一个布尔值，其中真TRUE=1，假FALSE=0,用来判断真假，如真就执行jump跳过去，假则继续执行下一个命令。此处为假，则继续执行下一个命令
```
DUP1
```
#### &emsp;再一次DUP1，还是复制栈顶元素并压栈
```
PUSH4 0x6057361d
```
#### &emsp;此时通过PUSH4押队4字节大小数据，此处也是压入函数签名0x6057361d，为store(uint256)的函数签名。
```
EQ
```
#### &emsp;再一次执行EQ命令。这时候执行完毕判断到栈顶2个元素相等，所以压入1到堆栈中。
```
PUSH2 0x0059
```
#### &emsp;压入0x0059到堆栈中，它的十进制表示为89，指向字节码中的第89条指令位置，也就是store(uint256)函数的开始位置。
```
JUMPI
```
#### &emsp;又一次JUMPI。此时布尔值是TRUE，意味着将会跳转过去到指向的指令位置执行。在字节码对应的位置，必须有可执行的操作码，如果没有的话，程序将不可执行。当前我们程序是有的，当JUMPI执行完毕后，我们会跳转到指向的位置，也就是store(uint256)函数的字节码去执行。
#### &emsp;当然我们的例子只有2个函数吗，其他的合约可能多于20+个函数也用如上的判断方式。
#### &emsp;你当前应该理解了以太坊虚拟机决定跳转到那个函数的字节码的方式。它只是简单的用“if”的方式轮训每个函数并根据函数提供的跳转位置去跳转执行。
<br>

# 以太坊虚拟机EVM 实验
#### &emsp;我这边推荐https://www.evm.codes/playground。练习以太坊命令。选择左边选项的助记符形式，输入当前的命令列表。实验中，你可以查看参数，放置于Calldata in HEX框框中。可以尝试放置store(uint256)以及retrieve()函数的输入参数。接着点击"RUN"按钮。并使用步入调试"step into"。按步理解操作码。
